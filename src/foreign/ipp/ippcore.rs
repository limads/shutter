/* automatically generated by rust-bindgen 0.57.0 */

pub const IPP_PI: f64 = 3.141592653589793;
pub const IPP_2PI: f64 = 6.283185307179586;
pub const IPP_PI2: f64 = 1.5707963267948966;
pub const IPP_PI4: f64 = 0.7853981633974483;
pub const IPP_PI180: f64 = 0.017453292519943295;
pub const IPP_RPI: f64 = 0.3183098861837907;
pub const IPP_SQRT2: f64 = 1.4142135623730951;
pub const IPP_SQRT3: f64 = 1.7320508075688772;
pub const IPP_LN2: f64 = 0.6931471805599453;
pub const IPP_LN3: f64 = 1.0986122886681098;
pub const IPP_E: f64 = 2.718281828459045;
pub const IPP_RE: f64 = 0.36787944117144233;
pub const IPP_MAX_8U: u32 = 255;
pub const IPP_MAX_16U: u32 = 65535;
pub const IPP_MAX_32U: u32 = 4294967295;
pub const IPP_MIN_8U: u32 = 0;
pub const IPP_MIN_16U: u32 = 0;
pub const IPP_MIN_32U: u32 = 0;
pub const IPP_MIN_8S: i32 = -128;
pub const IPP_MAX_8S: u32 = 127;
pub const IPP_MIN_16S: i32 = -32768;
pub const IPP_MAX_16S: u32 = 32767;
pub const IPP_MIN_32S: i32 = -2147483648;
pub const IPP_MAX_32S: u32 = 2147483647;
pub const IPP_MIN_64U: u32 = 0;
pub const IPP_MAX_64S: u64 = 9223372036854775807;
pub const IPP_MIN_64S: i64 = -9223372036854775808;
pub const IPP_MAX_64U: i32 = -1;
pub const ippCPUID_MMX: u32 = 1;
pub const ippCPUID_SSE: u32 = 2;
pub const ippCPUID_SSE2: u32 = 4;
pub const ippCPUID_SSE3: u32 = 8;
pub const ippCPUID_SSSE3: u32 = 16;
pub const ippCPUID_MOVBE: u32 = 32;
pub const ippCPUID_SSE41: u32 = 64;
pub const ippCPUID_SSE42: u32 = 128;
pub const ippCPUID_AVX: u32 = 256;
pub const ippAVX_ENABLEDBYOS: u32 = 512;
pub const ippCPUID_AES: u32 = 1024;
pub const ippCPUID_CLMUL: u32 = 2048;
pub const ippCPUID_ABR: u32 = 4096;
pub const ippCPUID_RDRAND: u32 = 8192;
pub const ippCPUID_F16C: u32 = 16384;
pub const ippCPUID_AVX2: u32 = 32768;
pub const ippCPUID_ADCOX: u32 = 65536;
pub const ippCPUID_RDSEED: u32 = 131072;
pub const ippCPUID_PREFETCHW: u32 = 262144;
pub const ippCPUID_SHA: u32 = 524288;
pub const ippCPUID_AVX512F: u32 = 1048576;
pub const ippCPUID_AVX512CD: u32 = 2097152;
pub const ippCPUID_AVX512ER: u32 = 4194304;
pub const ippCPUID_AVX512PF: u32 = 8388608;
pub const ippCPUID_AVX512BW: u32 = 16777216;
pub const ippCPUID_AVX512DQ: u32 = 33554432;
pub const ippCPUID_AVX512VL: u32 = 67108864;
pub const ippCPUID_AVX512VBMI: u32 = 134217728;
pub const ippCPUID_MPX: u32 = 268435456;
pub const ippCPUID_AVX512_4FMADDPS: u32 = 536870912;
pub const ippCPUID_AVX512_4VNNIW: u32 = 1073741824;
pub const ippCPUID_KNC: u32 = 2147483648;
pub const ABI_BAD_BX: u32 = 1;
pub const ABI_BAD_DI: u32 = 2;
pub const ABI_BAD_SI: u32 = 4;
pub const ABI_BAD_BP: u32 = 8;
pub const ABI_BAD_12: u32 = 16;
pub const ABI_BAD_13: u32 = 32;
pub const ABI_BAD_14: u32 = 64;
pub const ABI_BAD_15: u32 = 128;
pub const IPP_TEMPORAL_COPY: u32 = 0;
pub const IPP_NONTEMPORAL_STORE: u32 = 1;
pub const IPP_NONTEMPORAL_LOAD: u32 = 2;
pub const IPP_HOG_MAX_CELL: u32 = 16;
pub const IPP_HOG_MAX_BLOCK: u32 = 64;
pub const IPP_HOG_MAX_BINS: u32 = 16;
pub const IPP_SEGMENT_QUEUE: u32 = 1;
pub const IPP_SEGMENT_DISTANCE: u32 = 2;
pub const IPP_SEGMENT_BORDER_4: u32 = 64;
pub const IPP_SEGMENT_BORDER_8: u32 = 128;
pub const IppZFPMINBITS: u32 = 0;
pub const IppZFPMAXBITS: u32 = 4171;
pub const IppZFPMAXPREC: u32 = 64;
pub const IppZFPMINEXP: i32 = -10740;
pub const ippStsCpuNotSupportedErr: i32 = -9999;
pub const ippStsInplaceModeNotSupportedErr: i32 = -9998;
pub const ippStsIIRIIRLengthErr: i32 = -234;
pub const ippStsWarpTransformTypeErr: i32 = -233;
pub const ippStsExceededSizeErr: i32 = -232;
pub const ippStsWarpDirectionErr: i32 = -231;
pub const ippStsFilterTypeErr: i32 = -230;
pub const ippStsNormErr: i32 = -229;
pub const ippStsAlgTypeErr: i32 = -228;
pub const ippStsMisalignedOffsetErr: i32 = -227;
pub const ippStsBorderErr: i32 = -225;
pub const ippStsDitherTypeErr: i32 = -224;
pub const ippStsUnknownStatusCodeErr: i32 = -216;
pub const ippStsLzoBrokenStreamErr: i32 = -214;
pub const ippStsRoundModeNotSupportedErr: i32 = -213;
pub const ippStsDecimateFractionErr: i32 = -212;
pub const ippStsWeightErr: i32 = -211;
pub const ippStsQualityIndexErr: i32 = -210;
pub const ippStsIIRPassbandRippleErr: i32 = -209;
pub const ippStsFilterFrequencyErr: i32 = -208;
pub const ippStsIIRGenOrderErr: i32 = -206;
pub const ippStsConvergeErr: i32 = -205;
pub const ippStsSizeMatchMatrixErr: i32 = -204;
pub const ippStsCountMatrixErr: i32 = -203;
pub const ippStsRoiShiftMatrixErr: i32 = -202;
pub const ippStsSrcDataErr: i32 = -200;
pub const ippStsSingularErr: i32 = -195;
pub const ippStsSparseErr: i32 = -194;
pub const ippStsRegExpOptionsErr: i32 = -190;
pub const ippStsRegExpErr: i32 = -189;
pub const ippStsRegExpMatchLimitErr: i32 = -188;
pub const ippStsRegExpQuantifierErr: i32 = -187;
pub const ippStsRegExpGroupingErr: i32 = -186;
pub const ippStsRegExpBackRefErr: i32 = -185;
pub const ippStsRegExpChClassErr: i32 = -184;
pub const ippStsRegExpMetaChErr: i32 = -183;
pub const ippStsStrideMatrixErr: i32 = -182;
pub const ippStsNoiseRangeErr: i32 = -125;
pub const ippStsNotEvenStepErr: i32 = -108;
pub const ippStsHistoNofLevelsErr: i32 = -107;
pub const ippStsLUTNofLevelsErr: i32 = -106;
pub const ippStsChannelOrderErr: i32 = -60;
pub const ippStsDataTypeErr: i32 = -59;
pub const ippStsQuadErr: i32 = -58;
pub const ippStsRectErr: i32 = -57;
pub const ippStsCoeffErr: i32 = -56;
pub const ippStsNoiseValErr: i32 = -55;
pub const ippStsDitherLevelsErr: i32 = -54;
pub const ippStsNumChannelsErr: i32 = -53;
pub const ippStsCOIErr: i32 = -52;
pub const ippStsDivisorErr: i32 = -51;
pub const ippStsAlphaTypeErr: i32 = -50;
pub const ippStsGammaRangeErr: i32 = -49;
pub const ippStsChannelErr: i32 = -47;
pub const ippStsToneMagnErr: i32 = -46;
pub const ippStsToneFreqErr: i32 = -45;
pub const ippStsTonePhaseErr: i32 = -44;
pub const ippStsTrnglMagnErr: i32 = -43;
pub const ippStsTrnglFreqErr: i32 = -42;
pub const ippStsTrnglPhaseErr: i32 = -41;
pub const ippStsTrnglAsymErr: i32 = -40;
pub const ippStsHugeWinErr: i32 = -39;
pub const ippStsJaehneErr: i32 = -38;
pub const ippStsStrideErr: i32 = -37;
pub const ippStsEpsValErr: i32 = -36;
pub const ippStsWtOffsetErr: i32 = -35;
pub const ippStsAnchorErr: i32 = -34;
pub const ippStsMaskSizeErr: i32 = -33;
pub const ippStsShiftErr: i32 = -32;
pub const ippStsSampleFactorErr: i32 = -31;
pub const ippStsSamplePhaseErr: i32 = -30;
pub const ippStsFIRMRFactorErr: i32 = -29;
pub const ippStsFIRMRPhaseErr: i32 = -28;
pub const ippStsRelFreqErr: i32 = -27;
pub const ippStsFIRLenErr: i32 = -26;
pub const ippStsIIROrderErr: i32 = -25;
pub const ippStsResizeFactorErr: i32 = -24;
pub const ippStsInterpolationErr: i32 = -23;
pub const ippStsMirrorFlipErr: i32 = -22;
pub const ippStsMoment00ZeroErr: i32 = -21;
pub const ippStsThreshNegLevelErr: i32 = -20;
pub const ippStsThresholdErr: i32 = -19;
pub const ippStsFftFlagErr: i32 = -18;
pub const ippStsFftOrderErr: i32 = -17;
pub const ippStsStepErr: i32 = -16;
pub const ippStsLoadDynErr: i32 = -221;
pub const ippStsLengthErr: i32 = -15;
pub const ippStsNotSupportedModeErr: i32 = -14;
pub const ippStsContextMatchErr: i32 = -13;
pub const ippStsScaleRangeErr: i32 = -12;
pub const ippStsOutOfRangeErr: i32 = -11;
pub const ippStsDivByZeroErr: i32 = -10;
pub const ippStsMemAllocErr: i32 = -9;
pub const ippStsNullPtrErr: i32 = -8;
pub const ippStsRangeErr: i32 = -7;
pub const ippStsSizeErr: i32 = -6;
pub const ippStsBadArgErr: i32 = -5;
pub const ippStsNoMemErr: i32 = -4;
pub const ippStsErr: i32 = -2;
pub const ippStsNoErr: u32 = 0;
pub const ippStsNoOperation: u32 = 1;
pub const ippStsDivByZero: u32 = 2;
pub const ippStsWaterfall: u32 = 43;
pub const ippStsSqrtNegArg: u32 = 3;
pub const ippStsInvZero: u32 = 4;
pub const ippStsEvenMedianMaskSize: u32 = 5;
pub const ippStsLnZeroArg: u32 = 7;
pub const ippStsLnNegArg: u32 = 8;
pub const ippStsNanArg: u32 = 9;
pub const ippStsOverflow: u32 = 12;
pub const ippStsUnderflow: u32 = 17;
pub const ippStsSingularity: u32 = 18;
pub const ippStsDomain: u32 = 19;
pub const ippStsNonIntelCpu: u32 = 20;
pub const ippStsCpuMismatch: u32 = 21;
pub const ippStsOvermuchStrings: u32 = 26;
pub const ippStsOverlongString: u32 = 27;
pub const ippStsAffineQuadChanged: u32 = 28;
pub const ippStsWrongIntersectROI: u32 = 29;
pub const ippStsWrongIntersectQuad: u32 = 30;
pub const ippStsSrcSizeLessExpected: u32 = 32;
pub const ippStsDstSizeLessExpected: u32 = 33;
pub const ippStsDoubleSize: u32 = 35;
pub const ippStsNotSupportedCpu: u32 = 36;
pub const ippStsUnknownCacheSize: u32 = 37;
pub const ippStsSymKernelExpected: u32 = 38;
pub const ippStsEvenMedianWeight: u32 = 39;
pub const ippStsWrongIntersectVOI: u32 = 40;
pub const ippStsNoAntialiasing: u32 = 46;
pub const ippStsRepetitiveSrcData: u32 = 47;
pub const ippStsSizeWrn: u32 = 48;
pub const ippStsFeatureNotSupported: u32 = 49;
pub const ippStsUnknownFeature: u32 = 50;
pub const ippStsFeaturesCombination: u32 = 51;
pub const ippStsAccurateModeNotSupported: u32 = 52;
pub const ippStsNonOptimalPathSelected: u32 = 53;
pub const ippStsOk: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppLibraryVersion {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub majorBuild: ::std::os::raw::c_int,
    pub build: ::std::os::raw::c_int,
    pub targetCpu: [::std::os::raw::c_char; 4usize],
    pub Name: *const ::std::os::raw::c_char,
    pub Version: *const ::std::os::raw::c_char,
    pub BuildDate: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_IppLibraryVersion() {
    assert_eq!(
        ::std::mem::size_of::<IppLibraryVersion>(),
        48usize,
        concat!("Size of: ", stringify!(IppLibraryVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<IppLibraryVersion>(),
        8usize,
        concat!("Alignment of ", stringify!(IppLibraryVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLibraryVersion>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLibraryVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLibraryVersion>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLibraryVersion),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLibraryVersion>())).majorBuild as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLibraryVersion),
            "::",
            stringify!(majorBuild)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLibraryVersion>())).build as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLibraryVersion),
            "::",
            stringify!(build)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLibraryVersion>())).targetCpu as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLibraryVersion),
            "::",
            stringify!(targetCpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLibraryVersion>())).Name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLibraryVersion),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLibraryVersion>())).Version as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLibraryVersion),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLibraryVersion>())).BuildDate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLibraryVersion),
            "::",
            stringify!(BuildDate)
        )
    );
}
pub type Ipp8u = ::std::os::raw::c_uchar;
pub type Ipp16u = ::std::os::raw::c_ushort;
pub type Ipp32u = ::std::os::raw::c_uint;
pub type Ipp8s = ::std::os::raw::c_schar;
pub type Ipp16s = ::std::os::raw::c_short;
pub type Ipp32s = ::std::os::raw::c_int;
pub type Ipp32f = f32;
pub type Ipp64s = ::std::os::raw::c_longlong;
pub type Ipp64u = ::std::os::raw::c_ulonglong;
pub type Ipp64f = f64;
pub type Ipp16f = Ipp16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ipp8sc {
    pub re: Ipp8s,
    pub im: Ipp8s,
}
#[test]
fn bindgen_test_layout_Ipp8sc() {
    assert_eq!(
        ::std::mem::size_of::<Ipp8sc>(),
        2usize,
        concat!("Size of: ", stringify!(Ipp8sc))
    );
    assert_eq!(
        ::std::mem::align_of::<Ipp8sc>(),
        1usize,
        concat!("Alignment of ", stringify!(Ipp8sc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp8sc>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp8sc),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp8sc>())).im as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp8sc),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ipp16sc {
    pub re: Ipp16s,
    pub im: Ipp16s,
}
#[test]
fn bindgen_test_layout_Ipp16sc() {
    assert_eq!(
        ::std::mem::size_of::<Ipp16sc>(),
        4usize,
        concat!("Size of: ", stringify!(Ipp16sc))
    );
    assert_eq!(
        ::std::mem::align_of::<Ipp16sc>(),
        2usize,
        concat!("Alignment of ", stringify!(Ipp16sc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp16sc>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp16sc),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp16sc>())).im as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp16sc),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ipp16uc {
    pub re: Ipp16u,
    pub im: Ipp16u,
}
#[test]
fn bindgen_test_layout_Ipp16uc() {
    assert_eq!(
        ::std::mem::size_of::<Ipp16uc>(),
        4usize,
        concat!("Size of: ", stringify!(Ipp16uc))
    );
    assert_eq!(
        ::std::mem::align_of::<Ipp16uc>(),
        2usize,
        concat!("Alignment of ", stringify!(Ipp16uc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp16uc>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp16uc),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp16uc>())).im as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp16uc),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ipp32sc {
    pub re: Ipp32s,
    pub im: Ipp32s,
}
#[test]
fn bindgen_test_layout_Ipp32sc() {
    assert_eq!(
        ::std::mem::size_of::<Ipp32sc>(),
        8usize,
        concat!("Size of: ", stringify!(Ipp32sc))
    );
    assert_eq!(
        ::std::mem::align_of::<Ipp32sc>(),
        4usize,
        concat!("Alignment of ", stringify!(Ipp32sc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp32sc>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp32sc),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp32sc>())).im as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp32sc),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ipp32fc {
    pub re: Ipp32f,
    pub im: Ipp32f,
}
#[test]
fn bindgen_test_layout_Ipp32fc() {
    assert_eq!(
        ::std::mem::size_of::<Ipp32fc>(),
        8usize,
        concat!("Size of: ", stringify!(Ipp32fc))
    );
    assert_eq!(
        ::std::mem::align_of::<Ipp32fc>(),
        4usize,
        concat!("Alignment of ", stringify!(Ipp32fc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp32fc>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp32fc),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp32fc>())).im as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp32fc),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ipp64sc {
    pub re: Ipp64s,
    pub im: Ipp64s,
}
#[test]
fn bindgen_test_layout_Ipp64sc() {
    assert_eq!(
        ::std::mem::size_of::<Ipp64sc>(),
        16usize,
        concat!("Size of: ", stringify!(Ipp64sc))
    );
    assert_eq!(
        ::std::mem::align_of::<Ipp64sc>(),
        8usize,
        concat!("Alignment of ", stringify!(Ipp64sc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp64sc>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp64sc),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp64sc>())).im as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp64sc),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ipp64fc {
    pub re: Ipp64f,
    pub im: Ipp64f,
}
#[test]
fn bindgen_test_layout_Ipp64fc() {
    assert_eq!(
        ::std::mem::size_of::<Ipp64fc>(),
        16usize,
        concat!("Size of: ", stringify!(Ipp64fc))
    );
    assert_eq!(
        ::std::mem::align_of::<Ipp64fc>(),
        8usize,
        concat!("Alignment of ", stringify!(Ipp64fc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp64fc>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp64fc),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ipp64fc>())).im as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Ipp64fc),
            "::",
            stringify!(im)
        )
    );
}
pub const IppDataType_ippUndef: IppDataType = -1;
pub const IppDataType_ipp1u: IppDataType = 0;
pub const IppDataType_ipp8u: IppDataType = 1;
pub const IppDataType_ipp8uc: IppDataType = 2;
pub const IppDataType_ipp8s: IppDataType = 3;
pub const IppDataType_ipp8sc: IppDataType = 4;
pub const IppDataType_ipp16u: IppDataType = 5;
pub const IppDataType_ipp16uc: IppDataType = 6;
pub const IppDataType_ipp16s: IppDataType = 7;
pub const IppDataType_ipp16sc: IppDataType = 8;
pub const IppDataType_ipp32u: IppDataType = 9;
pub const IppDataType_ipp32uc: IppDataType = 10;
pub const IppDataType_ipp32s: IppDataType = 11;
pub const IppDataType_ipp32sc: IppDataType = 12;
pub const IppDataType_ipp32f: IppDataType = 13;
pub const IppDataType_ipp32fc: IppDataType = 14;
pub const IppDataType_ipp64u: IppDataType = 15;
pub const IppDataType_ipp64uc: IppDataType = 16;
pub const IppDataType_ipp64s: IppDataType = 17;
pub const IppDataType_ipp64sc: IppDataType = 18;
pub const IppDataType_ipp64f: IppDataType = 19;
pub const IppDataType_ipp64fc: IppDataType = 20;
pub type IppDataType = ::std::os::raw::c_int;
pub const IppBool_ippFalse: IppBool = 0;
pub const IppBool_ippTrue: IppBool = 1;
pub type IppBool = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppCache {
    pub type_: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IppCache() {
    assert_eq!(
        ::std::mem::size_of::<IppCache>(),
        12usize,
        concat!("Size of: ", stringify!(IppCache))
    );
    assert_eq!(
        ::std::mem::align_of::<IppCache>(),
        4usize,
        concat!("Alignment of ", stringify!(IppCache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppCache>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppCache),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppCache>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppCache),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppCache>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppCache),
            "::",
            stringify!(size)
        )
    );
}
pub const IppRoundMode_ippRndZero: IppRoundMode = 0;
pub const IppRoundMode_ippRndNear: IppRoundMode = 1;
pub const IppRoundMode_ippRndFinancial: IppRoundMode = 2;
pub const IppRoundMode_ippRndHintAccurate: IppRoundMode = 16;
pub type IppRoundMode = ::std::os::raw::c_uint;
pub const IppHintAlgorithm_ippAlgHintNone: IppHintAlgorithm = 0;
pub const IppHintAlgorithm_ippAlgHintFast: IppHintAlgorithm = 1;
pub const IppHintAlgorithm_ippAlgHintAccurate: IppHintAlgorithm = 2;
pub type IppHintAlgorithm = ::std::os::raw::c_uint;
pub const IppCmpOp_ippCmpLess: IppCmpOp = 0;
pub const IppCmpOp_ippCmpLessEq: IppCmpOp = 1;
pub const IppCmpOp_ippCmpEq: IppCmpOp = 2;
pub const IppCmpOp_ippCmpGreaterEq: IppCmpOp = 3;
pub const IppCmpOp_ippCmpGreater: IppCmpOp = 4;
pub type IppCmpOp = ::std::os::raw::c_uint;
pub const IppAlgType_ippAlgAuto: IppAlgType = 0;
pub const IppAlgType_ippAlgDirect: IppAlgType = 1;
pub const IppAlgType_ippAlgFFT: IppAlgType = 2;
pub const IppAlgType_ippAlgMask: IppAlgType = 255;
pub type IppAlgType = ::std::os::raw::c_uint;
pub const IppsNormOp_ippsNormNone: IppsNormOp = 0;
pub const IppsNormOp_ippsNormA: IppsNormOp = 256;
pub const IppsNormOp_ippsNormB: IppsNormOp = 512;
pub const IppsNormOp_ippsNormMask: IppsNormOp = 65280;
pub type IppsNormOp = ::std::os::raw::c_uint;
pub const IppNormType_ippNormInf: IppNormType = 1;
pub const IppNormType_ippNormL1: IppNormType = 2;
pub const IppNormType_ippNormL2: IppNormType = 4;
pub type IppNormType = ::std::os::raw::c_uint;
pub const IPP_FFT_DIV_FWD_BY_N: ::std::os::raw::c_uint = 1;
pub const IPP_FFT_DIV_INV_BY_N: ::std::os::raw::c_uint = 2;
pub const IPP_FFT_DIV_BY_SQRTN: ::std::os::raw::c_uint = 4;
pub const IPP_FFT_NODIV_BY_ANY: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const IPP_DIV_FWD_BY_N: ::std::os::raw::c_uint = 1;
pub const IPP_DIV_INV_BY_N: ::std::os::raw::c_uint = 2;
pub const IPP_DIV_BY_SQRTN: ::std::os::raw::c_uint = 4;
pub const IPP_NODIV_BY_ANY: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppPointPolar {
    pub rho: Ipp32f,
    pub theta: Ipp32f,
}
#[test]
fn bindgen_test_layout_IppPointPolar() {
    assert_eq!(
        ::std::mem::size_of::<IppPointPolar>(),
        8usize,
        concat!("Size of: ", stringify!(IppPointPolar))
    );
    assert_eq!(
        ::std::mem::align_of::<IppPointPolar>(),
        4usize,
        concat!("Alignment of ", stringify!(IppPointPolar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppPointPolar>())).rho as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppPointPolar),
            "::",
            stringify!(rho)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppPointPolar>())).theta as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppPointPolar),
            "::",
            stringify!(theta)
        )
    );
}
pub const IppWinType_ippWinBartlett: IppWinType = 0;
pub const IppWinType_ippWinBlackman: IppWinType = 1;
pub const IppWinType_ippWinHamming: IppWinType = 2;
pub const IppWinType_ippWinHann: IppWinType = 3;
pub const IppWinType_ippWinRect: IppWinType = 4;
pub type IppWinType = ::std::os::raw::c_uint;
pub const IppsIIRFilterType_ippButterworth: IppsIIRFilterType = 0;
pub const IppsIIRFilterType_ippChebyshev1: IppsIIRFilterType = 1;
pub type IppsIIRFilterType = ::std::os::raw::c_uint;
pub const IppsZCType_ippZCR: IppsZCType = 0;
pub const IppsZCType_ippZCXor: IppsZCType = 1;
pub const IppsZCType_ippZCC: IppsZCType = 2;
pub type IppsZCType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppsROI {
    pub left: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IppsROI() {
    assert_eq!(
        ::std::mem::size_of::<IppsROI>(),
        8usize,
        concat!("Size of: ", stringify!(IppsROI))
    );
    assert_eq!(
        ::std::mem::align_of::<IppsROI>(),
        4usize,
        concat!("Alignment of ", stringify!(IppsROI))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppsROI>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppsROI),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppsROI>())).right as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppsROI),
            "::",
            stringify!(right)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RandUniState_8u {
    _unused: [u8; 0],
}
pub type IppsRandUniState_8u = RandUniState_8u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RandUniState_16s {
    _unused: [u8; 0],
}
pub type IppsRandUniState_16s = RandUniState_16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RandUniState_32f {
    _unused: [u8; 0],
}
pub type IppsRandUniState_32f = RandUniState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RandUniState_64f {
    _unused: [u8; 0],
}
pub type IppsRandUniState_64f = RandUniState_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RandGaussState_8u {
    _unused: [u8; 0],
}
pub type IppsRandGaussState_8u = RandGaussState_8u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RandGaussState_16s {
    _unused: [u8; 0],
}
pub type IppsRandGaussState_16s = RandGaussState_16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RandGaussState_32f {
    _unused: [u8; 0],
}
pub type IppsRandGaussState_32f = RandGaussState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RandGaussState_64f {
    _unused: [u8; 0],
}
pub type IppsRandGaussState_64f = RandGaussState_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTSpec_C_32fc {
    _unused: [u8; 0],
}
pub type IppsFFTSpec_C_32fc = FFTSpec_C_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTSpec_C_32f {
    _unused: [u8; 0],
}
pub type IppsFFTSpec_C_32f = FFTSpec_C_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTSpec_R_32f {
    _unused: [u8; 0],
}
pub type IppsFFTSpec_R_32f = FFTSpec_R_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTSpec_C_64fc {
    _unused: [u8; 0],
}
pub type IppsFFTSpec_C_64fc = FFTSpec_C_64fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTSpec_C_64f {
    _unused: [u8; 0],
}
pub type IppsFFTSpec_C_64f = FFTSpec_C_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTSpec_R_64f {
    _unused: [u8; 0],
}
pub type IppsFFTSpec_R_64f = FFTSpec_R_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFTSpec_C_32fc {
    _unused: [u8; 0],
}
pub type IppsDFTSpec_C_32fc = DFTSpec_C_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFTSpec_C_32f {
    _unused: [u8; 0],
}
pub type IppsDFTSpec_C_32f = DFTSpec_C_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFTSpec_R_32f {
    _unused: [u8; 0],
}
pub type IppsDFTSpec_R_32f = DFTSpec_R_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFTSpec_C_64fc {
    _unused: [u8; 0],
}
pub type IppsDFTSpec_C_64fc = DFTSpec_C_64fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFTSpec_C_64f {
    _unused: [u8; 0],
}
pub type IppsDFTSpec_C_64f = DFTSpec_C_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFTSpec_R_64f {
    _unused: [u8; 0],
}
pub type IppsDFTSpec_R_64f = DFTSpec_R_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCTFwdSpec_32f {
    _unused: [u8; 0],
}
pub type IppsDCTFwdSpec_32f = DCTFwdSpec_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCTInvSpec_32f {
    _unused: [u8; 0],
}
pub type IppsDCTInvSpec_32f = DCTInvSpec_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCTFwdSpec_64f {
    _unused: [u8; 0],
}
pub type IppsDCTFwdSpec_64f = DCTFwdSpec_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCTInvSpec_64f {
    _unused: [u8; 0],
}
pub type IppsDCTInvSpec_64f = DCTInvSpec_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sWTFwdState_32f {
    _unused: [u8; 0],
}
pub type IppsWTFwdState_32f = sWTFwdState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sWTFwdState_8u32f {
    _unused: [u8; 0],
}
pub type IppsWTFwdState_8u32f = sWTFwdState_8u32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sWTFwdState_16s32f {
    _unused: [u8; 0],
}
pub type IppsWTFwdState_16s32f = sWTFwdState_16s32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sWTFwdState_16u32f {
    _unused: [u8; 0],
}
pub type IppsWTFwdState_16u32f = sWTFwdState_16u32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sWTInvState_32f {
    _unused: [u8; 0],
}
pub type IppsWTInvState_32f = sWTInvState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sWTInvState_32f8u {
    _unused: [u8; 0],
}
pub type IppsWTInvState_32f8u = sWTInvState_32f8u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sWTInvState_32f16s {
    _unused: [u8; 0],
}
pub type IppsWTInvState_32f16s = sWTInvState_32f16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sWTInvState_32f16u {
    _unused: [u8; 0],
}
pub type IppsWTInvState_32f16u = sWTInvState_32f16u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState_32f {
    _unused: [u8; 0],
}
pub type IppsIIRState_32f = IIRState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState_32fc {
    _unused: [u8; 0],
}
pub type IppsIIRState_32fc = IIRState_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState32f_16s {
    _unused: [u8; 0],
}
pub type IppsIIRState32f_16s = IIRState32f_16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState32fc_16sc {
    _unused: [u8; 0],
}
pub type IppsIIRState32fc_16sc = IIRState32fc_16sc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState_64f {
    _unused: [u8; 0],
}
pub type IppsIIRState_64f = IIRState_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState_64fc {
    _unused: [u8; 0],
}
pub type IppsIIRState_64fc = IIRState_64fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState64f_32f {
    _unused: [u8; 0],
}
pub type IppsIIRState64f_32f = IIRState64f_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState64fc_32fc {
    _unused: [u8; 0],
}
pub type IppsIIRState64fc_32fc = IIRState64fc_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState64f_32s {
    _unused: [u8; 0],
}
pub type IppsIIRState64f_32s = IIRState64f_32s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState64fc_32sc {
    _unused: [u8; 0],
}
pub type IppsIIRState64fc_32sc = IIRState64fc_32sc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState64f_16s {
    _unused: [u8; 0],
}
pub type IppsIIRState64f_16s = IIRState64f_16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRState64fc_16sc {
    _unused: [u8; 0],
}
pub type IppsIIRState64fc_16sc = IIRState64fc_16sc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRSpec_32f {
    _unused: [u8; 0],
}
pub type IppsFIRSpec_32f = FIRSpec_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRSpec_64f {
    _unused: [u8; 0],
}
pub type IppsFIRSpec_64f = FIRSpec_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRSpec_32fc {
    _unused: [u8; 0],
}
pub type IppsFIRSpec_32fc = FIRSpec_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRSpec_64fc {
    _unused: [u8; 0],
}
pub type IppsFIRSpec_64fc = FIRSpec_64fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRSpec32f_32fc {
    _unused: [u8; 0],
}
pub type IppsFIRSpec32f_32fc = FIRSpec32f_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRLMSState_32f {
    _unused: [u8; 0],
}
pub type IppsFIRLMSState_32f = FIRLMSState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRLMSState32f_16s {
    _unused: [u8; 0],
}
pub type IppsFIRLMSState32f_16s = FIRLMSState32f_16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HilbertSpec {
    _unused: [u8; 0],
}
pub type IppsHilbertSpec = HilbertSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRSparseState_32f {
    _unused: [u8; 0],
}
pub type IppsFIRSparseState_32f = FIRSparseState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IIRSparseState_32f {
    _unused: [u8; 0],
}
pub type IppsIIRSparseState_32f = IIRSparseState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIRSparseState_32fc {
    _unused: [u8; 0],
}
pub type IppsFIRSparseState_32fc = FIRSparseState_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResamplingPolyphase_16s {
    _unused: [u8; 0],
}
pub type IppsResamplingPolyphase_16s = ResamplingPolyphase_16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResamplingPolyphaseFixed_16s {
    _unused: [u8; 0],
}
pub type IppsResamplingPolyphaseFixed_16s = ResamplingPolyphaseFixed_16s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResamplingPolyphase_32f {
    _unused: [u8; 0],
}
pub type IppsResamplingPolyphase_32f = ResamplingPolyphase_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResamplingPolyphaseFixed_32f {
    _unused: [u8; 0],
}
pub type IppsResamplingPolyphaseFixed_32f = ResamplingPolyphaseFixed_32f;
pub type IppEnum = ::std::os::raw::c_int;
pub const IppiNormOp_ippiNormNone: IppiNormOp = 0;
pub const IppiNormOp_ippiNorm: IppiNormOp = 256;
pub const IppiNormOp_ippiNormCoefficient: IppiNormOp = 512;
pub const IppiNormOp_ippiNormMask: IppiNormOp = 65280;
pub type IppiNormOp = ::std::os::raw::c_uint;
pub const IppiROIShape_ippiROIFull: IppiROIShape = 0;
pub const IppiROIShape_ippiROIValid: IppiROIShape = 65536;
pub const IppiROIShape_ippiROISame: IppiROIShape = 131072;
pub const IppiROIShape_ippiROIMask: IppiROIShape = 16711680;
pub type IppiROIShape = ::std::os::raw::c_uint;
pub const IppChannels_ippC0: IppChannels = 0;
pub const IppChannels_ippC1: IppChannels = 1;
pub const IppChannels_ippC2: IppChannels = 2;
pub const IppChannels_ippC3: IppChannels = 3;
pub const IppChannels_ippC4: IppChannels = 4;
pub const IppChannels_ippP2: IppChannels = 5;
pub const IppChannels_ippP3: IppChannels = 6;
pub const IppChannels_ippP4: IppChannels = 7;
pub const IppChannels_ippAC1: IppChannels = 8;
pub const IppChannels_ippAC4: IppChannels = 9;
pub const IppChannels_ippA0C4: IppChannels = 10;
pub const IppChannels_ippAP4: IppChannels = 11;
pub type IppChannels = ::std::os::raw::c_uint;
pub const _IppiBorderType_ippBorderRepl: _IppiBorderType = 1;
pub const _IppiBorderType_ippBorderWrap: _IppiBorderType = 2;
pub const _IppiBorderType_ippBorderMirror: _IppiBorderType = 3;
pub const _IppiBorderType_ippBorderMirrorR: _IppiBorderType = 4;
pub const _IppiBorderType_ippBorderDefault: _IppiBorderType = 5;
pub const _IppiBorderType_ippBorderConst: _IppiBorderType = 6;
pub const _IppiBorderType_ippBorderTransp: _IppiBorderType = 7;
pub const _IppiBorderType_ippBorderInMemTop: _IppiBorderType = 16;
pub const _IppiBorderType_ippBorderInMemBottom: _IppiBorderType = 32;
pub const _IppiBorderType_ippBorderInMemLeft: _IppiBorderType = 64;
pub const _IppiBorderType_ippBorderInMemRight: _IppiBorderType = 128;
pub const _IppiBorderType_ippBorderInMem: _IppiBorderType = 240;
pub const _IppiBorderType_ippBorderFirstStageInMemTop: _IppiBorderType = 256;
pub const _IppiBorderType_ippBorderFirstStageInMemBottom: _IppiBorderType = 512;
pub const _IppiBorderType_ippBorderFirstStageInMemLeft: _IppiBorderType = 1024;
pub const _IppiBorderType_ippBorderFirstStageInMemRight: _IppiBorderType = 2048;
pub const _IppiBorderType_ippBorderFirstStageInMem: _IppiBorderType = 3840;
pub type _IppiBorderType = ::std::os::raw::c_uint;
pub use self::_IppiBorderType as IppiBorderType;
pub const IppiAxis_ippAxsHorizontal: IppiAxis = 0;
pub const IppiAxis_ippAxsVertical: IppiAxis = 1;
pub const IppiAxis_ippAxsBoth: IppiAxis = 2;
pub const IppiAxis_ippAxs45: IppiAxis = 3;
pub const IppiAxis_ippAxs135: IppiAxis = 4;
pub type IppiAxis = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiRect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IppiRect() {
    assert_eq!(
        ::std::mem::size_of::<IppiRect>(),
        16usize,
        concat!("Size of: ", stringify!(IppiRect))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiRect>(),
        4usize,
        concat!("Alignment of ", stringify!(IppiRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiRect>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiRect>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiRect),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiPoint {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IppiPoint() {
    assert_eq!(
        ::std::mem::size_of::<IppiPoint>(),
        8usize,
        concat!("Size of: ", stringify!(IppiPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(IppiPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiPoint),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiSize {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IppiSize() {
    assert_eq!(
        ::std::mem::size_of::<IppiSize>(),
        8usize,
        concat!("Size of: ", stringify!(IppiSize))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiSize>(),
        4usize,
        concat!("Alignment of ", stringify!(IppiSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiSize>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiSize),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiSize>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiSize),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiPoint_32f {
    pub x: Ipp32f,
    pub y: Ipp32f,
}
#[test]
fn bindgen_test_layout_IppiPoint_32f() {
    assert_eq!(
        ::std::mem::size_of::<IppiPoint_32f>(),
        8usize,
        concat!("Size of: ", stringify!(IppiPoint_32f))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiPoint_32f>(),
        4usize,
        concat!("Alignment of ", stringify!(IppiPoint_32f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiPoint_32f>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiPoint_32f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiPoint_32f>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiPoint_32f),
            "::",
            stringify!(y)
        )
    );
}
pub const _IppiMaskSize_ippMskSize1x3: _IppiMaskSize = 13;
pub const _IppiMaskSize_ippMskSize1x5: _IppiMaskSize = 15;
pub const _IppiMaskSize_ippMskSize3x1: _IppiMaskSize = 31;
pub const _IppiMaskSize_ippMskSize3x3: _IppiMaskSize = 33;
pub const _IppiMaskSize_ippMskSize5x1: _IppiMaskSize = 51;
pub const _IppiMaskSize_ippMskSize5x5: _IppiMaskSize = 55;
pub type _IppiMaskSize = ::std::os::raw::c_uint;
pub use self::_IppiMaskSize as IppiMaskSize;
pub const IPPI_INTER_NN: ::std::os::raw::c_int = 1;
pub const IPPI_INTER_LINEAR: ::std::os::raw::c_int = 2;
pub const IPPI_INTER_CUBIC: ::std::os::raw::c_int = 4;
pub const IPPI_INTER_CUBIC2P_BSPLINE: ::std::os::raw::c_int = 5;
pub const IPPI_INTER_CUBIC2P_CATMULLROM: ::std::os::raw::c_int = 6;
pub const IPPI_INTER_CUBIC2P_B05C03: ::std::os::raw::c_int = 7;
pub const IPPI_INTER_SUPER: ::std::os::raw::c_int = 8;
pub const IPPI_INTER_LANCZOS: ::std::os::raw::c_int = 16;
pub const IPPI_ANTIALIASING: ::std::os::raw::c_int = 536870912;
pub const IPPI_SUBPIXEL_EDGE: ::std::os::raw::c_int = 1073741824;
pub const IPPI_SMOOTH_EDGE: ::std::os::raw::c_int = -2147483648;
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
pub const IppiInterpolationType_ippNearest: IppiInterpolationType = 1;
pub const IppiInterpolationType_ippLinear: IppiInterpolationType = 2;
pub const IppiInterpolationType_ippCubic: IppiInterpolationType = 6;
pub const IppiInterpolationType_ippLanczos: IppiInterpolationType = 16;
pub const IppiInterpolationType_ippHahn: IppiInterpolationType = 0;
pub const IppiInterpolationType_ippSuper: IppiInterpolationType = 8;
pub type IppiInterpolationType = ::std::os::raw::c_uint;
pub const IppiFraction_ippPolyphase_1_2: IppiFraction = 0;
pub const IppiFraction_ippPolyphase_3_5: IppiFraction = 1;
pub const IppiFraction_ippPolyphase_2_3: IppiFraction = 2;
pub const IppiFraction_ippPolyphase_7_10: IppiFraction = 3;
pub const IppiFraction_ippPolyphase_3_4: IppiFraction = 4;
pub type IppiFraction = ::std::os::raw::c_uint;
pub const IPP_FASTN_ORIENTATION: ::std::os::raw::c_uint = 1;
pub const IPP_FASTN_NMS: ::std::os::raw::c_uint = 2;
pub const IPP_FASTN_CIRCLE: ::std::os::raw::c_uint = 4;
pub const IPP_FASTN_SCORE_MODE0: ::std::os::raw::c_uint = 32;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const IppiAlphaType_ippAlphaOver: IppiAlphaType = 0;
pub const IppiAlphaType_ippAlphaIn: IppiAlphaType = 1;
pub const IppiAlphaType_ippAlphaOut: IppiAlphaType = 2;
pub const IppiAlphaType_ippAlphaATop: IppiAlphaType = 3;
pub const IppiAlphaType_ippAlphaXor: IppiAlphaType = 4;
pub const IppiAlphaType_ippAlphaPlus: IppiAlphaType = 5;
pub const IppiAlphaType_ippAlphaOverPremul: IppiAlphaType = 6;
pub const IppiAlphaType_ippAlphaInPremul: IppiAlphaType = 7;
pub const IppiAlphaType_ippAlphaOutPremul: IppiAlphaType = 8;
pub const IppiAlphaType_ippAlphaATopPremul: IppiAlphaType = 9;
pub const IppiAlphaType_ippAlphaXorPremul: IppiAlphaType = 10;
pub const IppiAlphaType_ippAlphaPlusPremul: IppiAlphaType = 11;
pub type IppiAlphaType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeconvFFTState_32f_C1R {
    _unused: [u8; 0],
}
pub type IppiDeconvFFTState_32f_C1R = DeconvFFTState_32f_C1R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeconvFFTState_32f_C3R {
    _unused: [u8; 0],
}
pub type IppiDeconvFFTState_32f_C3R = DeconvFFTState_32f_C3R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeconvLR_32f_C1R {
    _unused: [u8; 0],
}
pub type IppiDeconvLR_32f_C1R = DeconvLR_32f_C1R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeconvLR_32f_C3R {
    _unused: [u8; 0],
}
pub type IppiDeconvLR_32f_C3R = DeconvLR_32f_C3R;
pub const IppiFilterBilateralType_ippiFilterBilateralGauss: IppiFilterBilateralType = 100;
pub const IppiFilterBilateralType_ippiFilterBilateralGaussFast: IppiFilterBilateralType = 101;
pub type IppiFilterBilateralType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterBilateralSpec {
    _unused: [u8; 0],
}
pub type IppiFilterBilateralSpec = FilterBilateralSpec;
pub const IppiDistanceMethodType_ippDistNormL1: IppiDistanceMethodType = 2;
pub const IppiDistanceMethodType_ippDistNormL2: IppiDistanceMethodType = 4;
pub type IppiDistanceMethodType = ::std::os::raw::c_uint;
pub const IppiResizeFilterType_ippResizeFilterHann: IppiResizeFilterType = 0;
pub const IppiResizeFilterType_ippResizeFilterLanczos: IppiResizeFilterType = 1;
pub type IppiResizeFilterType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResizeFilterState {
    _unused: [u8; 0],
}
pub type IppiResizeFilterState = ResizeFilterState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiBorderSize {
    pub borderLeft: Ipp32u,
    pub borderTop: Ipp32u,
    pub borderRight: Ipp32u,
    pub borderBottom: Ipp32u,
}
#[test]
fn bindgen_test_layout_IppiBorderSize() {
    assert_eq!(
        ::std::mem::size_of::<IppiBorderSize>(),
        16usize,
        concat!("Size of: ", stringify!(IppiBorderSize))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiBorderSize>(),
        4usize,
        concat!("Alignment of ", stringify!(IppiBorderSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiBorderSize>())).borderLeft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiBorderSize),
            "::",
            stringify!(borderLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiBorderSize>())).borderTop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiBorderSize),
            "::",
            stringify!(borderTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiBorderSize>())).borderRight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiBorderSize),
            "::",
            stringify!(borderRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiBorderSize>())).borderBottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiBorderSize),
            "::",
            stringify!(borderBottom)
        )
    );
}
pub const IppiWarpDirection_ippWarpForward: IppiWarpDirection = 0;
pub const IppiWarpDirection_ippWarpBackward: IppiWarpDirection = 1;
pub type IppiWarpDirection = ::std::os::raw::c_uint;
pub const IppiWarpTransformType_ippWarpAffine: IppiWarpTransformType = 0;
pub const IppiWarpTransformType_ippWarpPerspective: IppiWarpTransformType = 1;
pub const IppiWarpTransformType_ippWarpBilinear: IppiWarpTransformType = 2;
pub type IppiWarpTransformType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResizeSpec_32f {
    _unused: [u8; 0],
}
pub type IppiResizeSpec_32f = ResizeSpec_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResizeYUV422Spec {
    _unused: [u8; 0],
}
pub type IppiResizeYUV422Spec = ResizeYUV422Spec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResizeYUV420Spec {
    _unused: [u8; 0],
}
pub type IppiResizeYUV420Spec = ResizeYUV420Spec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResizeSpec_64f {
    _unused: [u8; 0],
}
pub type IppiResizeSpec_64f = ResizeSpec_64f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiWarpSpec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterBorderSpec {
    _unused: [u8; 0],
}
pub type IppiFilterBorderSpec = FilterBorderSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThresholdAdaptiveSpec {
    _unused: [u8; 0],
}
pub type IppiThresholdAdaptiveSpec = ThresholdAdaptiveSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HistogramSpec {
    _unused: [u8; 0],
}
pub type IppiHistogramSpec = HistogramSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiHOGConfig {
    pub cvCompatible: ::std::os::raw::c_int,
    pub cellSize: ::std::os::raw::c_int,
    pub blockSize: ::std::os::raw::c_int,
    pub blockStride: ::std::os::raw::c_int,
    pub nbins: ::std::os::raw::c_int,
    pub sigma: Ipp32f,
    pub l2thresh: Ipp32f,
    pub winSize: IppiSize,
}
#[test]
fn bindgen_test_layout_IppiHOGConfig() {
    assert_eq!(
        ::std::mem::size_of::<IppiHOGConfig>(),
        36usize,
        concat!("Size of: ", stringify!(IppiHOGConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiHOGConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(IppiHOGConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiHOGConfig>())).cvCompatible as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiHOGConfig),
            "::",
            stringify!(cvCompatible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiHOGConfig>())).cellSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiHOGConfig),
            "::",
            stringify!(cellSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiHOGConfig>())).blockSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiHOGConfig),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiHOGConfig>())).blockStride as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiHOGConfig),
            "::",
            stringify!(blockStride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiHOGConfig>())).nbins as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiHOGConfig),
            "::",
            stringify!(nbins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiHOGConfig>())).sigma as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiHOGConfig),
            "::",
            stringify!(sigma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiHOGConfig>())).l2thresh as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiHOGConfig),
            "::",
            stringify!(l2thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiHOGConfig>())).winSize as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiHOGConfig),
            "::",
            stringify!(winSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFT2DSpec_C_32fc {
    _unused: [u8; 0],
}
pub type IppiFFTSpec_C_32fc = FFT2DSpec_C_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFT2DSpec_R_32f {
    _unused: [u8; 0],
}
pub type IppiFFTSpec_R_32f = FFT2DSpec_R_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFT2DSpec_C_32fc {
    _unused: [u8; 0],
}
pub type IppiDFTSpec_C_32fc = DFT2DSpec_C_32fc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DFT2DSpec_R_32f {
    _unused: [u8; 0],
}
pub type IppiDFTSpec_R_32f = DFT2DSpec_R_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCT2DFwdSpec_32f {
    _unused: [u8; 0],
}
pub type IppiDCTFwdSpec_32f = DCT2DFwdSpec_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCT2DInvSpec_32f {
    _unused: [u8; 0],
}
pub type IppiDCTInvSpec_32f = DCT2DInvSpec_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iWTFwdSpec_32f_C1R {
    _unused: [u8; 0],
}
pub type IppiWTFwdSpec_32f_C1R = iWTFwdSpec_32f_C1R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iWTInvSpec_32f_C1R {
    _unused: [u8; 0],
}
pub type IppiWTInvSpec_32f_C1R = iWTInvSpec_32f_C1R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iWTFwdSpec_32f_C3R {
    _unused: [u8; 0],
}
pub type IppiWTFwdSpec_32f_C3R = iWTFwdSpec_32f_C3R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iWTInvSpec_32f_C3R {
    _unused: [u8; 0],
}
pub type IppiWTInvSpec_32f_C3R = iWTInvSpec_32f_C3R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MomentState64f {
    _unused: [u8; 0],
}
pub type IppiMomentState_64f = MomentState64f;
pub type IppiHuMoment_64f = [Ipp64f; 7usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LUT_Spec {
    _unused: [u8; 0],
}
pub type IppiLUT_Spec = LUT_Spec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ipHOG {
    _unused: [u8; 0],
}
pub type IppiHOGSpec = _ipHOG;
#[doc = " Below are 3D Image (Volume) Processing specific definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IpprVolume {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IpprVolume() {
    assert_eq!(
        ::std::mem::size_of::<IpprVolume>(),
        12usize,
        concat!("Size of: ", stringify!(IpprVolume))
    );
    assert_eq!(
        ::std::mem::align_of::<IpprVolume>(),
        4usize,
        concat!("Alignment of ", stringify!(IpprVolume))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprVolume>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprVolume),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprVolume>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprVolume),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprVolume>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprVolume),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IpprCuboid {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IpprCuboid() {
    assert_eq!(
        ::std::mem::size_of::<IpprCuboid>(),
        24usize,
        concat!("Size of: ", stringify!(IpprCuboid))
    );
    assert_eq!(
        ::std::mem::align_of::<IpprCuboid>(),
        4usize,
        concat!("Alignment of ", stringify!(IpprCuboid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprCuboid>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprCuboid),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprCuboid>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprCuboid),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprCuboid>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprCuboid),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprCuboid>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprCuboid),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprCuboid>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprCuboid),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprCuboid>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprCuboid),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IpprPoint {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IpprPoint() {
    assert_eq!(
        ::std::mem::size_of::<IpprPoint>(),
        12usize,
        concat!("Size of: ", stringify!(IpprPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<IpprPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(IpprPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprPoint),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprPoint>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprPoint),
            "::",
            stringify!(z)
        )
    );
}
pub const _IppiDifferentialKernel_ippFilterSobelVert: _IppiDifferentialKernel = 0;
pub const _IppiDifferentialKernel_ippFilterSobelHoriz: _IppiDifferentialKernel = 1;
pub const _IppiDifferentialKernel_ippFilterSobel: _IppiDifferentialKernel = 2;
pub const _IppiDifferentialKernel_ippFilterScharrVert: _IppiDifferentialKernel = 3;
pub const _IppiDifferentialKernel_ippFilterScharrHoriz: _IppiDifferentialKernel = 4;
pub const _IppiDifferentialKernel_ippFilterScharr: _IppiDifferentialKernel = 5;
pub const _IppiDifferentialKernel_ippFilterCentralDiffVert: _IppiDifferentialKernel = 6;
pub const _IppiDifferentialKernel_ippFilterCentralDiffHoriz: _IppiDifferentialKernel = 7;
pub const _IppiDifferentialKernel_ippFilterCentralDiff: _IppiDifferentialKernel = 8;
pub type _IppiDifferentialKernel = ::std::os::raw::c_uint;
pub use self::_IppiDifferentialKernel as IppiDifferentialKernel;
pub const _IppiKernelType_ippKernelSobel: _IppiKernelType = 0;
pub const _IppiKernelType_ippKernelScharr: _IppiKernelType = 1;
pub const _IppiKernelType_ippKernelSobelNeg: _IppiKernelType = 2;
pub type _IppiKernelType = ::std::os::raw::c_uint;
pub use self::_IppiKernelType as IppiKernelType;
pub const _IppiNorm_ippiNormInf: _IppiNorm = 0;
pub const _IppiNorm_ippiNormL1: _IppiNorm = 1;
pub const _IppiNorm_ippiNormL2: _IppiNorm = 2;
pub const _IppiNorm_ippiNormFM: _IppiNorm = 3;
pub type _IppiNorm = ::std::os::raw::c_uint;
pub use self::_IppiNorm as IppiNorm;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvMorphState {
    _unused: [u8; 0],
}
pub type IppiMorphState = ipcvMorphState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvMorphStateL {
    _unused: [u8; 0],
}
pub type IppiMorphStateL = ipcvMorphStateL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvMorphAdvState {
    _unused: [u8; 0],
}
pub type IppiMorphAdvState = ipcvMorphAdvState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvMorphAdvStateL {
    _unused: [u8; 0],
}
pub type IppiMorphAdvStateL = ipcvMorphAdvStateL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvMorphGrayState_8u {
    _unused: [u8; 0],
}
pub type IppiMorphGrayState_8u = ipcvMorphGrayState_8u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvMorphGrayState_8uL {
    _unused: [u8; 0],
}
pub type IppiMorphGrayState_8uL = ipcvMorphGrayState_8uL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvMorphGrayState_32f {
    _unused: [u8; 0],
}
pub type IppiMorphGrayState_32f = ipcvMorphGrayState_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvMorphGrayState_32fL {
    _unused: [u8; 0],
}
pub type IppiMorphGrayState_32fL = ipcvMorphGrayState_32fL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvConvState {
    _unused: [u8; 0],
}
pub type IppiConvState = ipcvConvState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IppiConnectedComp {
    pub area: Ipp64f,
    pub value: [Ipp64f; 3usize],
    pub rect: IppiRect,
}
#[test]
fn bindgen_test_layout__IppiConnectedComp() {
    assert_eq!(
        ::std::mem::size_of::<_IppiConnectedComp>(),
        48usize,
        concat!("Size of: ", stringify!(_IppiConnectedComp))
    );
    assert_eq!(
        ::std::mem::align_of::<_IppiConnectedComp>(),
        8usize,
        concat!("Alignment of ", stringify!(_IppiConnectedComp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiConnectedComp>())).area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiConnectedComp),
            "::",
            stringify!(area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiConnectedComp>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiConnectedComp),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiConnectedComp>())).rect as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiConnectedComp),
            "::",
            stringify!(rect)
        )
    );
}
pub type IppiConnectedComp = _IppiConnectedComp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PyramidState {
    _unused: [u8; 0],
}
pub type IppiPyramidState = PyramidState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterSeparableSpec {
    _unused: [u8; 0],
}
pub type IppiFilterSeparableSpec = FilterSeparableSpec;
pub type IppiPyramidDownState_8u_C1R = IppiPyramidState;
pub type IppiPyramidDownState_16u_C1R = IppiPyramidState;
pub type IppiPyramidDownState_32f_C1R = IppiPyramidState;
pub type IppiPyramidDownState_8u_C3R = IppiPyramidState;
pub type IppiPyramidDownState_16u_C3R = IppiPyramidState;
pub type IppiPyramidDownState_32f_C3R = IppiPyramidState;
pub type IppiPyramidUpState_8u_C1R = IppiPyramidState;
pub type IppiPyramidUpState_16u_C1R = IppiPyramidState;
pub type IppiPyramidUpState_32f_C1R = IppiPyramidState;
pub type IppiPyramidUpState_8u_C3R = IppiPyramidState;
pub type IppiPyramidUpState_16u_C3R = IppiPyramidState;
pub type IppiPyramidUpState_32f_C3R = IppiPyramidState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IppiPyramid {
    pub pImage: *mut *mut Ipp8u,
    pub pRoi: *mut IppiSize,
    pub pRate: *mut Ipp64f,
    pub pStep: *mut ::std::os::raw::c_int,
    pub pState: *mut Ipp8u,
    pub level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IppiPyramid() {
    assert_eq!(
        ::std::mem::size_of::<_IppiPyramid>(),
        48usize,
        concat!("Size of: ", stringify!(_IppiPyramid))
    );
    assert_eq!(
        ::std::mem::align_of::<_IppiPyramid>(),
        8usize,
        concat!("Alignment of ", stringify!(_IppiPyramid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiPyramid>())).pImage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiPyramid),
            "::",
            stringify!(pImage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiPyramid>())).pRoi as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiPyramid),
            "::",
            stringify!(pRoi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiPyramid>())).pRate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiPyramid),
            "::",
            stringify!(pRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiPyramid>())).pStep as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiPyramid),
            "::",
            stringify!(pStep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiPyramid>())).pState as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiPyramid),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiPyramid>())).level as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiPyramid),
            "::",
            stringify!(level)
        )
    );
}
pub type IppiPyramid = _IppiPyramid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OptFlowPyrLK {
    _unused: [u8; 0],
}
pub type IppiOptFlowPyrLK = OptFlowPyrLK;
pub type IppiOptFlowPyrLK_8u_C1R = IppiOptFlowPyrLK;
pub type IppiOptFlowPyrLK_16u_C1R = IppiOptFlowPyrLK;
pub type IppiOptFlowPyrLK_32f_C1R = IppiOptFlowPyrLK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvHaarClassifier_32f {
    _unused: [u8; 0],
}
pub type IppiHaarClassifier_32f = ipcvHaarClassifier_32f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvHaarClassifier_32s {
    _unused: [u8; 0],
}
pub type IppiHaarClassifier_32s = ipcvHaarClassifier_32s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvFGHistogramState_8u_C1R {
    _unused: [u8; 0],
}
pub type IppFGHistogramState_8u_C1R = ipcvFGHistogramState_8u_C1R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvFGHistogramState_8u_C3R {
    _unused: [u8; 0],
}
pub type IppFGHistogramState_8u_C3R = ipcvFGHistogramState_8u_C3R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvFGGaussianState_8u_C1R {
    _unused: [u8; 0],
}
pub type IppFGGaussianState_8u_C1R = ipcvFGGaussianState_8u_C1R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvFGGaussianState_8u_C3R {
    _unused: [u8; 0],
}
pub type IppFGGaussianState_8u_C3R = ipcvFGGaussianState_8u_C3R;
pub const _IppiInpaintFlag_IPP_INPAINT_TELEA: _IppiInpaintFlag = 0;
pub const _IppiInpaintFlag_IPP_INPAINT_NS: _IppiInpaintFlag = 1;
pub type _IppiInpaintFlag = ::std::os::raw::c_uint;
pub use self::_IppiInpaintFlag as IppiInpaintFlag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ippcvFilterGaussianSpec {
    _unused: [u8; 0],
}
pub type IppFilterGaussianSpec = ippcvFilterGaussianSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipcvInpaintState_8u {
    _unused: [u8; 0],
}
pub type IppiInpaintState_8u_C1R = ipcvInpaintState_8u;
pub type IppiInpaintState_8u_C3R = ipcvInpaintState_8u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HoughProbSpec {
    _unused: [u8; 0],
}
pub type IppiHoughProbSpec = HoughProbSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FastNSpec {
    _unused: [u8; 0],
}
pub type IppiFastNSpec = FastNSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IppiCornerFastN {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub cornerType: ::std::os::raw::c_int,
    pub orientation: ::std::os::raw::c_int,
    pub angle: f32,
    pub score: f32,
}
#[test]
fn bindgen_test_layout__IppiCornerFastN() {
    assert_eq!(
        ::std::mem::size_of::<_IppiCornerFastN>(),
        24usize,
        concat!("Size of: ", stringify!(_IppiCornerFastN))
    );
    assert_eq!(
        ::std::mem::align_of::<_IppiCornerFastN>(),
        4usize,
        concat!("Alignment of ", stringify!(_IppiCornerFastN))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiCornerFastN>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiCornerFastN),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiCornerFastN>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiCornerFastN),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiCornerFastN>())).cornerType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiCornerFastN),
            "::",
            stringify!(cornerType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiCornerFastN>())).orientation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiCornerFastN),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiCornerFastN>())).angle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiCornerFastN),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IppiCornerFastN>())).score as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IppiCornerFastN),
            "::",
            stringify!(score)
        )
    );
}
pub type IppiCornerFastN = _IppiCornerFastN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FGMMState_8u_C3R {
    _unused: [u8; 0],
}
pub type IppFGMMState_8u_C3R = FGMMState_8u_C3R;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppFGMModel {
    pub numFrames: ::std::os::raw::c_uint,
    pub maxNGauss: ::std::os::raw::c_uint,
    pub varInit: Ipp32f,
    pub varMin: Ipp32f,
    pub varMax: Ipp32f,
    pub varWBRatio: Ipp32f,
    pub bckgThr: Ipp32f,
    pub varNGRatio: Ipp32f,
    pub reduction: Ipp32f,
    pub shadowValue: Ipp8u,
    pub shadowFlag: ::std::os::raw::c_char,
    pub shadowRatio: Ipp32f,
}
#[test]
fn bindgen_test_layout_IppFGMModel() {
    assert_eq!(
        ::std::mem::size_of::<IppFGMModel>(),
        44usize,
        concat!("Size of: ", stringify!(IppFGMModel))
    );
    assert_eq!(
        ::std::mem::align_of::<IppFGMModel>(),
        4usize,
        concat!("Alignment of ", stringify!(IppFGMModel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).numFrames as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(numFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).maxNGauss as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(maxNGauss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).varInit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(varInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).varMin as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(varMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).varMax as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(varMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).varWBRatio as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(varWBRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).bckgThr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(bckgThr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).varNGRatio as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(varNGRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).reduction as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(reduction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).shadowValue as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(shadowValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).shadowFlag as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(shadowFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppFGMModel>())).shadowRatio as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IppFGMModel),
            "::",
            stringify!(shadowRatio)
        )
    );
}
pub const IPP_UPPER: ::std::os::raw::c_uint = 1;
pub const IPP_LEFT: ::std::os::raw::c_uint = 2;
pub const IPP_CENTER: ::std::os::raw::c_uint = 4;
pub const IPP_RIGHT: ::std::os::raw::c_uint = 8;
pub const IPP_LOWER: ::std::os::raw::c_uint = 16;
pub const IPP_UPPER_LEFT: ::std::os::raw::c_uint = 32;
pub const IPP_UPPER_RIGHT: ::std::os::raw::c_uint = 64;
pub const IPP_LOWER_LEFT: ::std::os::raw::c_uint = 128;
pub const IPP_LOWER_RIGHT: ::std::os::raw::c_uint = 256;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const IppiDitherType_ippDitherNone: IppiDitherType = 0;
pub const IppiDitherType_ippDitherFS: IppiDitherType = 1;
pub const IppiDitherType_ippDitherJJN: IppiDitherType = 2;
pub const IppiDitherType_ippDitherStucki: IppiDitherType = 3;
pub const IppiDitherType_ippDitherBayer: IppiDitherType = 4;
pub type IppiDitherType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppRegExpFind {
    pub pFind: *mut ::std::os::raw::c_void,
    pub lenFind: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IppRegExpFind() {
    assert_eq!(
        ::std::mem::size_of::<IppRegExpFind>(),
        16usize,
        concat!("Size of: ", stringify!(IppRegExpFind))
    );
    assert_eq!(
        ::std::mem::align_of::<IppRegExpFind>(),
        8usize,
        concat!("Alignment of ", stringify!(IppRegExpFind))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppRegExpFind>())).pFind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppRegExpFind),
            "::",
            stringify!(pFind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppRegExpFind>())).lenFind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppRegExpFind),
            "::",
            stringify!(lenFind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RegExpState {
    _unused: [u8; 0],
}
pub type IppRegExpState = RegExpState;
pub const IppRegExpFormat_ippFmtASCII: IppRegExpFormat = 0;
pub const IppRegExpFormat_ippFmtUTF8: IppRegExpFormat = 1;
pub type IppRegExpFormat = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RegExpReplaceState {
    _unused: [u8; 0],
}
pub type IppRegExpReplaceState = RegExpReplaceState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MTFState_8u {
    _unused: [u8; 0],
}
pub type IppMTFState_8u = MTFState_8u;
pub const IppBWTSortAlgorithmHint_ippBWTItohTanakaLimSort: IppBWTSortAlgorithmHint = 0;
pub const IppBWTSortAlgorithmHint_ippBWTItohTanakaUnlimSort: IppBWTSortAlgorithmHint = 1;
pub const IppBWTSortAlgorithmHint_ippBWTSuffixSort: IppBWTSortAlgorithmHint = 2;
pub const IppBWTSortAlgorithmHint_ippBWTAutoSort: IppBWTSortAlgorithmHint = 3;
pub type IppBWTSortAlgorithmHint = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZSSState_8u {
    _unused: [u8; 0],
}
pub type IppLZSSState_8u = LZSSState_8u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ77State_8u {
    _unused: [u8; 0],
}
pub type IppLZ77State_8u = LZ77State_8u;
pub const IppLZ77ComprLevel_IppLZ77FastCompr: IppLZ77ComprLevel = 0;
pub const IppLZ77ComprLevel_IppLZ77AverageCompr: IppLZ77ComprLevel = 1;
pub const IppLZ77ComprLevel_IppLZ77BestCompr: IppLZ77ComprLevel = 2;
pub type IppLZ77ComprLevel = ::std::os::raw::c_uint;
pub const IppLZ77Chcksm_IppLZ77NoChcksm: IppLZ77Chcksm = 0;
pub const IppLZ77Chcksm_IppLZ77Adler32: IppLZ77Chcksm = 1;
pub const IppLZ77Chcksm_IppLZ77CRC32: IppLZ77Chcksm = 2;
pub type IppLZ77Chcksm = ::std::os::raw::c_uint;
pub const IppLZ77Flush_IppLZ77NoFlush: IppLZ77Flush = 0;
pub const IppLZ77Flush_IppLZ77SyncFlush: IppLZ77Flush = 1;
pub const IppLZ77Flush_IppLZ77FullFlush: IppLZ77Flush = 2;
pub const IppLZ77Flush_IppLZ77FinishFlush: IppLZ77Flush = 3;
pub type IppLZ77Flush = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppLZ77Pairs_16u {
    pub length: Ipp16u,
    pub offset: Ipp16u,
}
#[test]
fn bindgen_test_layout_IppLZ77Pairs_16u() {
    assert_eq!(
        ::std::mem::size_of::<IppLZ77Pairs_16u>(),
        4usize,
        concat!("Size of: ", stringify!(IppLZ77Pairs_16u))
    );
    assert_eq!(
        ::std::mem::align_of::<IppLZ77Pairs_16u>(),
        2usize,
        concat!("Alignment of ", stringify!(IppLZ77Pairs_16u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLZ77Pairs_16u>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLZ77Pairs_16u),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppLZ77Pairs_16u>())).offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IppLZ77Pairs_16u),
            "::",
            stringify!(offset)
        )
    );
}
pub type IppLZ77Pair = IppLZ77Pairs_16u;
pub const IppLZ77DeflateStatus_IppLZ77StatusInit: IppLZ77DeflateStatus = 0;
pub const IppLZ77DeflateStatus_IppLZ77StatusLZ77Process: IppLZ77DeflateStatus = 1;
pub const IppLZ77DeflateStatus_IppLZ77StatusHuffProcess: IppLZ77DeflateStatus = 2;
pub const IppLZ77DeflateStatus_IppLZ77StatusFinal: IppLZ77DeflateStatus = 3;
pub type IppLZ77DeflateStatus = ::std::os::raw::c_uint;
pub const IppLZ77HuffMode_IppLZ77UseFixed: IppLZ77HuffMode = 0;
pub const IppLZ77HuffMode_IppLZ77UseDynamic: IppLZ77HuffMode = 1;
pub const IppLZ77HuffMode_IppLZ77UseStored: IppLZ77HuffMode = 2;
pub type IppLZ77HuffMode = ::std::os::raw::c_uint;
pub const IppLZ77InflateStatus_IppLZ77InflateStatusInit: IppLZ77InflateStatus = 0;
pub const IppLZ77InflateStatus_IppLZ77InflateStatusHuffProcess: IppLZ77InflateStatus = 1;
pub const IppLZ77InflateStatus_IppLZ77InflateStatusLZ77Process: IppLZ77InflateStatus = 2;
pub const IppLZ77InflateStatus_IppLZ77InflateStatusFinal: IppLZ77InflateStatus = 3;
pub type IppLZ77InflateStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppInflateState {
    pub pWindow: *const Ipp8u,
    pub winSize: ::std::os::raw::c_uint,
    pub tableType: ::std::os::raw::c_uint,
    pub tableBufferSize: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_IppInflateState() {
    assert_eq!(
        ::std::mem::size_of::<IppInflateState>(),
        24usize,
        concat!("Size of: ", stringify!(IppInflateState))
    );
    assert_eq!(
        ::std::mem::align_of::<IppInflateState>(),
        8usize,
        concat!("Alignment of ", stringify!(IppInflateState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppInflateState>())).pWindow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppInflateState),
            "::",
            stringify!(pWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppInflateState>())).winSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppInflateState),
            "::",
            stringify!(winSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppInflateState>())).tableType as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IppInflateState),
            "::",
            stringify!(tableType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppInflateState>())).tableBufferSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IppInflateState),
            "::",
            stringify!(tableBufferSize)
        )
    );
}
pub const IppInflateMode_ippTYPE: IppInflateMode = 0;
pub const IppInflateMode_ippLEN: IppInflateMode = 1;
pub const IppInflateMode_ippLENEXT: IppInflateMode = 2;
pub type IppInflateMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppDeflateFreqTable {
    pub freq: Ipp16u,
    pub code: Ipp16u,
}
#[test]
fn bindgen_test_layout_IppDeflateFreqTable() {
    assert_eq!(
        ::std::mem::size_of::<IppDeflateFreqTable>(),
        4usize,
        concat!("Size of: ", stringify!(IppDeflateFreqTable))
    );
    assert_eq!(
        ::std::mem::align_of::<IppDeflateFreqTable>(),
        2usize,
        concat!("Alignment of ", stringify!(IppDeflateFreqTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppDeflateFreqTable>())).freq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppDeflateFreqTable),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppDeflateFreqTable>())).code as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IppDeflateFreqTable),
            "::",
            stringify!(code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppDeflateHuffCode {
    pub code: Ipp16u,
    pub len: Ipp16u,
}
#[test]
fn bindgen_test_layout_IppDeflateHuffCode() {
    assert_eq!(
        ::std::mem::size_of::<IppDeflateHuffCode>(),
        4usize,
        concat!("Size of: ", stringify!(IppDeflateHuffCode))
    );
    assert_eq!(
        ::std::mem::align_of::<IppDeflateHuffCode>(),
        2usize,
        concat!("Alignment of ", stringify!(IppDeflateHuffCode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppDeflateHuffCode>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppDeflateHuffCode),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppDeflateHuffCode>())).len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IppDeflateHuffCode),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RLEState_BZ2 {
    _unused: [u8; 0],
}
pub type IppRLEState_BZ2 = RLEState_BZ2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EncodeHuffState_BZ2 {
    _unused: [u8; 0],
}
pub type IppEncodeHuffState_BZ2 = EncodeHuffState_BZ2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DecodeHuffState_BZ2 {
    _unused: [u8; 0],
}
pub type IppDecodeHuffState_BZ2 = DecodeHuffState_BZ2;
pub const IppLZOMethod_IppLZO1XST: IppLZOMethod = 0;
pub const IppLZOMethod_IppLZO1XMT: IppLZOMethod = 1;
pub const IppLZOMethod_IppLZO1X1ST: IppLZOMethod = 2;
pub type IppLZOMethod = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZOState_8u {
    _unused: [u8; 0],
}
pub type IppLZOState_8u = LZOState_8u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZfpState_32f {
    _unused: [u8; 0],
}
pub type IppEncodeZfpState_32f = ZfpState_32f;
pub type IppDecodeZfpState_32f = ZfpState_32f;
pub const IppPatternMatchMode_ippPatternMatchAuto: IppPatternMatchMode = 0;
pub const IppPatternMatchMode_ippPatternMatchDirect: IppPatternMatchMode = 1;
pub const IppPatternMatchMode_ippPatternMatchTable: IppPatternMatchMode = 2;
pub type IppPatternMatchMode = ::std::os::raw::c_uint;
pub const IppTopKMode_ippTopKAuto: IppTopKMode = 0;
pub const IppTopKMode_ippTopKDirect: IppTopKMode = 1;
pub const IppTopKMode_ippTopKRadix: IppTopKMode = 2;
pub type IppTopKMode = ::std::os::raw::c_uint;
pub type IppStatus = ::std::os::raw::c_int;
pub type IppSizeL = Ipp64s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiRectL {
    pub x: IppSizeL,
    pub y: IppSizeL,
    pub width: IppSizeL,
    pub height: IppSizeL,
}
#[test]
fn bindgen_test_layout_IppiRectL() {
    assert_eq!(
        ::std::mem::size_of::<IppiRectL>(),
        32usize,
        concat!("Size of: ", stringify!(IppiRectL))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiRectL>(),
        8usize,
        concat!("Alignment of ", stringify!(IppiRectL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiRectL>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiRectL),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiRectL>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiRectL),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiRectL>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiRectL),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiRectL>())).height as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiRectL),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiPointL {
    pub x: IppSizeL,
    pub y: IppSizeL,
}
#[test]
fn bindgen_test_layout_IppiPointL() {
    assert_eq!(
        ::std::mem::size_of::<IppiPointL>(),
        16usize,
        concat!("Size of: ", stringify!(IppiPointL))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiPointL>(),
        8usize,
        concat!("Alignment of ", stringify!(IppiPointL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiPointL>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiPointL),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiPointL>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiPointL),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IppiSizeL {
    pub width: IppSizeL,
    pub height: IppSizeL,
}
#[test]
fn bindgen_test_layout_IppiSizeL() {
    assert_eq!(
        ::std::mem::size_of::<IppiSizeL>(),
        16usize,
        concat!("Size of: ", stringify!(IppiSizeL))
    );
    assert_eq!(
        ::std::mem::align_of::<IppiSizeL>(),
        8usize,
        concat!("Alignment of ", stringify!(IppiSizeL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiSizeL>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiSizeL),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IppiSizeL>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IppiSizeL),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IpprVolumeL {
    pub width: IppSizeL,
    pub height: IppSizeL,
    pub depth: IppSizeL,
}
#[test]
fn bindgen_test_layout_IpprVolumeL() {
    assert_eq!(
        ::std::mem::size_of::<IpprVolumeL>(),
        24usize,
        concat!("Size of: ", stringify!(IpprVolumeL))
    );
    assert_eq!(
        ::std::mem::align_of::<IpprVolumeL>(),
        8usize,
        concat!("Alignment of ", stringify!(IpprVolumeL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprVolumeL>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprVolumeL),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprVolumeL>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprVolumeL),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprVolumeL>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprVolumeL),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IpprPointL {
    pub x: IppSizeL,
    pub y: IppSizeL,
    pub z: IppSizeL,
}
#[test]
fn bindgen_test_layout_IpprPointL() {
    assert_eq!(
        ::std::mem::size_of::<IpprPointL>(),
        24usize,
        concat!("Size of: ", stringify!(IpprPointL))
    );
    assert_eq!(
        ::std::mem::align_of::<IpprPointL>(),
        8usize,
        concat!("Alignment of ", stringify!(IpprPointL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprPointL>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprPointL),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprPointL>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprPointL),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IpprPointL>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IpprPointL),
            "::",
            stringify!(z)
        )
    );
}
pub const _IpprBorderType_ipprBorderRepl: _IpprBorderType = 1;
pub const _IpprBorderType_ipprBorderConst: _IpprBorderType = 6;
pub const _IpprBorderType_ipprBorderInMemTop: _IpprBorderType = 16;
pub const _IpprBorderType_ipprBorderInMemBottom: _IpprBorderType = 32;
pub const _IpprBorderType_ipprBorderInMemLeft: _IpprBorderType = 64;
pub const _IpprBorderType_ipprBorderInMemRight: _IpprBorderType = 128;
pub const _IpprBorderType_ipprBorderInMemFront: _IpprBorderType = 4096;
pub const _IpprBorderType_ipprBorderInMemBack: _IpprBorderType = 8192;
pub const _IpprBorderType_ipprBorderInMem: _IpprBorderType = 12528;
pub type _IpprBorderType = ::std::os::raw::c_uint;
pub use self::_IpprBorderType as IpprBorderType;
pub const IppiMorphMode_IPP_MORPH_DEFAULT: IppiMorphMode = 0;
pub const IppiMorphMode_IPP_MORPH_MASK_NO_FLIP: IppiMorphMode = 1;
pub const IppiMorphMode_IPP_MORPH_NO_THRESHOLD: IppiMorphMode = 4;
pub type IppiMorphMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResizeSpec {
    _unused: [u8; 0],
}
pub type IppiResizeSpec = ResizeSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterBilateralType_T {
    _unused: [u8; 0],
}
pub type IppiFilterBilateralSpec_T = FilterBilateralType_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterBilateralType_LT {
    _unused: [u8; 0],
}
pub type IppiFilterBilateralSpec_LT = FilterBilateralType_LT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResizeSpec_LT {
    _unused: [u8; 0],
}
pub type IppiResizeSpec_LT = ResizeSpec_LT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterSobelType_T {
    _unused: [u8; 0],
}
pub type IppiFilterSobelSpec_T = FilterSobelType_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterBorderSpecV {
    _unused: [u8; 0],
}
pub type IpprFilterBorderSpec = FilterBorderSpecV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterMedianSpecV {
    _unused: [u8; 0],
}
pub type IpprFilterMedianSpec = FilterMedianSpecV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IpprFilterBorderType_T {
    _unused: [u8; 0],
}
pub type IpprFilterBorderSpec_T = IpprFilterBorderType_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IpprFilterBorderType_LT {
    _unused: [u8; 0],
}
pub type IpprFilterBorderSpec_LT = IpprFilterBorderType_LT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IpprFilterMedianType_T {
    _unused: [u8; 0],
}
pub type IpprFilterMedianSpec_T = IpprFilterMedianType_T;
extern "C" {
    pub fn ippMalloc_L(length: IppSizeL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ippGetLibVersion() -> *const IppLibraryVersion;
}
extern "C" {
    pub fn ippGetStatusString(StsCode: IppStatus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ippGetCpuClocks() -> Ipp64u;
}
extern "C" {
    pub fn ippSetFlushToZero(
        value: ::std::os::raw::c_int,
        pUMask: *mut ::std::os::raw::c_uint,
    ) -> IppStatus;
}
extern "C" {
    pub fn ippSetDenormAreZeros(value: ::std::os::raw::c_int) -> IppStatus;
}
extern "C" {
    pub fn ippAlignPtr(
        ptr: *mut ::std::os::raw::c_void,
        alignBytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ippMalloc(length: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ippFree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ippInit() -> IppStatus;
}
extern "C" {
    pub fn ippGetCpuFreqMhz(pMhz: *mut ::std::os::raw::c_int) -> IppStatus;
}
extern "C" {
    pub fn ippSetNumThreads(numThr: ::std::os::raw::c_int) -> IppStatus;
}
extern "C" {
    pub fn ippGetNumThreads(pNumThr: *mut ::std::os::raw::c_int) -> IppStatus;
}
extern "C" {
    pub fn ippGetMaxCacheSizeB(pSizeByte: *mut ::std::os::raw::c_int) -> IppStatus;
}
extern "C" {
    pub fn ippGetCpuFeatures(pFeaturesMask: *mut Ipp64u, pCpuidInfoRegs: *mut Ipp32u) -> IppStatus;
}
extern "C" {
    pub fn ippGetEnabledCpuFeatures() -> Ipp64u;
}
extern "C" {
    pub fn ippSetCpuFeatures(cpuFeatures: Ipp64u) -> IppStatus;
}
extern "C" {
    pub fn ippGetCacheParams(ppCacheInfo: *mut *mut IppCache) -> IppStatus;
}
extern "C" {
    pub fn ippGetL2CacheSize(pSize: *mut ::std::os::raw::c_int) -> IppStatus;
}
